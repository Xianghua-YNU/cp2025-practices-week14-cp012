# 受驱单摆的非线性动力学实验报告

## 1. 实验目的

简要描述本实验的主要目标：
1. 实现并比较不同数值方法求解受驱单摆方程的效果
2. 研究受驱单摆系统的共振现象
3. 分析系统在不同参数下的混沌行为

## 2. 理论背景

### 2.1 受驱单摆方程

简要介绍受驱单摆的运动方程及其物理意义：
- 方程的推导过程
- 各项参数的物理含义
- 无量纲化处理（如果使用）
运动方程为:θ"+gsinθ/l=CcosΩt
推导过程：先进行受力分析，将重力力矩与驱动力力矩联立关系，再利用转动方程代入求解。
θ为摆角，θ'为角速度依次类推，g为重力加速度，l为摆长，C为驱动力强度，Ω为驱动频率
无量纲方程：d^2θ/dt^2+sinθ=C~cosΩ~t
### 2.2 数值方法

简要说明使用的数值方法原理：
1. 欧拉法
   - 基本原理：通过当前点导数线性外推下一步
   - 误差阶数：局部截断误差：O(h^2) 全局误差：O(h)
   - 优缺点：优点：实现简单，计算量小。缺点：精度低，稳定性差。

2. 改进欧拉法
   - 改进的思路：引入预测-矫正机制，先以欧拉法预测，再用导数平均值更新结果
   - 误差阶数：O(h^2)
   - 与简单欧拉法的比较：精度更高，稳定性更好，计算量增大

3. 四阶龙格-库塔法
   - 方法原理：通过四个斜率加权平均提高精度
   - 误差阶数：O(h^4)
   - 计算效率分析：高精度，稳定性高，但计算量大

## 3. 实验方法

### 3.1 代码实现

简要说明各个函数的实现思路：
1. `forced_pendulum_ode`函数
   - 实现要点：输入参数以及对应公式
   - 关键步骤说明：将一阶导数直接由Ω代替，节省计算量同时便于计算。
   - theta, omega = state
    dtheta_dt = omega
    domega_dt = -(g / l) * np.sin(theta) + C * np.cos(Omega * t)*np.sin(Omega*t)

2. 数值求解方法
   - 欧拉法实现要点：显式迭代，步长固定
   - 改进欧拉法实现要点：预测矫正，二阶精度
   - RK4方法实现要点：斜率加权平均，自适应步长

### 3.2 实验参数

列出实验中使用的主要参数：
- 阻尼系数 γ
- 驱动频率 ω_d
- 驱动力幅度 F_d
- 初始条件
- 时间步长
- 其他相关参数

## 4. 实验结果与分析

### 4.1 数值方法比较

1. 不同方法的数值解比较
   - 插入时间序列图:![FORCE](https://github.com/user-attachments/assets/4f8d040f-d72c-4587-8e38-a92934cc69d4)

   - 分析三种方法的计算结果差异:欧拉法最大振幅大，误差也最大，改进法次之，RK4最小
   - 讨论数值稳定性：欧拉法当步长大于2/Ω时完全发散，误差随时间累积；改进法可容忍更大步长，但仍然不够；RK4稳定性极好

2. 计算效率比较
   - 比较不同方法的计算时间：欧拉法用时最短，改进法次之，RK4用时最长
   - 分析精度和效率的权衡：在共振频率附近时，误差越低，精度越高，时间越长，要使效率最高可使用欧拉法快速定性分析，再以RK4自适应步长求得最佳值，最后选择出最佳位置。

### 4.2 共振现象分析

1. 共振曲线
   - 插入幅频特性图：![force2](https://github.com/user-attachments/assets/eb7bc824-9145-49a2-9795-5a8c1b2a9804)

   - 分析共振频率：峰值出现在5.0左右，与预期值十分符合，稍有偏差，可能是由于数值阻尼效应
   - 讨论阻尼对共振的影响：阻尼增大，振幅降低，共振峰变宽，临界阻尼时共振现象消失

2. 特征分析
   - 描述观察到的共振特征：低频区随Ω线性增长，共振区出现尖锐峰值，高频区以比值形式衰减
   - 与理论预期的比较：峰值出现位置Ω相近，存在偏差，相位变化平滑。

### 4.3 混沌行为研究

1. 相空间分析
   - 插入相空间图：![force3](https://github.com/user-attachments/assets/73d10876-bb9b-4938-b829-a07be1135d2c)

   - 描述轨道特征：周期运动，最后进入混沌
   - 分析混沌的产生条件：具有参数阈值，由多个周期演化而来

2. 参数依赖性
   - 不同参数下的系统行为：随C增大逐渐陷入混沌状态，随Ω增大由锁频到周期再到混沌
   - 混沌转捩的特征：随C增大而逐渐混沌，由极限环到振荡到混沌到完全混沌

## 5. 讨论

1. 数值方法的适用性
   - 各方法的优缺点:欧拉法：优点为实现简单，计算速度快，缺点为一阶精度，稳定性差；改进法：优点为二阶精度，稳定性较好，缺点计算量较大；RK4：优点为四阶精度，稳定性极好，缺点计算量极大，实现复杂。
   - 最佳方法的选择建议：1.用欧拉法快速验证模型；2.利用RK4计算步长；3.采用solve_ivp自适应方法

2. 物理现象的解释
   - 共振机理：当Ω接近系统固有频率时，外力每周期做功最大
   - 混沌产生的机制：1.非线性恢复力；2.驱动力足够强；3.进行演化
   - 与其他物理系统的类比：1.与LC振荡电路，拥有相同共振频率公式；2.量子谐振子，离散能级类似分岔序列

3. 实验中遇到的问题和解决方法
   - 数值计算中的困难：1.数值发散；2.相位漂移；3.虚假阻尼；4.共振峰缺失
   - 参数选择的考虑：1.步长选择须满足小于0，1min(2Π/Ω，2Π/Ω0)；2.模拟时长至少包含50个驱动周期
   - 改进建议：1.代码优化，利用numpy；2.可视化增强，增加指数演化等；3.通过理论验证

## 6. 结论

总结实验的主要发现：
1. 数值方法的比较结果：欧拉法：优点为实现简单，计算速度快，缺点为一阶精度，稳定性差；改进法：优点为二阶精度，稳定性较好，缺点计算量较大；RK4：优点为四阶精度，稳定性极好，缺点计算量极大，实现复杂。
2. 受驱单摆的动力学特征：基本行为模式：小角度运动——线性振荡——非线性软化——周期倍化——混沌运动。参数影响规律，随C和Ω发生变化
3. 共振和混沌现象的主要特点：共振：1.当频率接近系统固有频率时，振幅急剧增大，非线性系统会出现共振频率偏移；2.能量高效传递，功率吸收最大化；3.振幅响应特征；4.非线性效应。混沌：1.由完全确定方程产生看似随机的运动，对初值敏感；2.演化路径：小角度运动——线性振荡——非线性软化——周期倍化——混沌运动；3.有相空间特征，庞加莱截面呈分形结构。

## 7. 参考文献

列出参考的文献资料：
1. 教材和参考书
2. 相关论文
3. 网络资源
Deepseek等AI搜索 理论力学教材 知乎文章
## 附录：核心代码

附上关键函数的代码实现（建议只包含最核心的部分）：

```python
# 在此粘贴核心代码
def forced_pendulum_ode(t, state, l, g, C, Omega):
    """
    受驱单摆的常微分方程
    state: [theta, omega]
    返回: [dtheta/dt, domega/dt]
    """
    theta, omega = state
    dtheta_dt = omega
    domega_dt = -(g / l) * np.sin(theta) + C * np.cos(Omega * t)*np.sin(Omega*t)
    return [dtheta_dt, domega_dt]
def solve_pendulum(l=0.1, g=9.81, C=2, Omega=5, t_span=(0, 100), y0=[0, 0]):
    """
    求解受迫单摆运动方程
    返回: t, theta
    """
    # 使用solve_ivp求解ODE
    sol = solve_ivp(forced_pendulum_ode, t_span, y0,
                    args=(l, g, C, Omega),
                    t_eval=np.linspace(t_span[0], t_span[1], 2000),
                    rtol=1e-6, atol=1e-8)
    return sol.t, sol.y[0]
def find_resonance(l=0.1, g=9.81, C=2, Omega_range=None, t_span=(0, 200), y0=[0, 0]):
    """
    寻找共振频率
    返回: Omega_range, amplitudes
    """
    if Omega_range is None:
        Omega_range = np.linspace(0.1, 20, 50)
    amplitudes = []
    for Omega in Omega_range:
        t, theta = solve_pendulum(l, g, C, Omega, t_span, y0)
        # 取最后1/2的数据计算振幅，避免瞬态响应

        steady_idx = t > t_span[0] + (t_span[1] - t_span[0]) / 2
        amplitude = np.max(np.abs(theta[steady_idx]))
        amplitudes.append(amplitude)
    return Omega_range, np.array(amplitudes)
```
